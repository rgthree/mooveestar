<!DOCTYPE HTML>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>MooVeeStar: Put Your App in the Spotlight</title>
    <meta name="description" content="MooVeeStar is a client-side MV* Framework built ontop of MooTools.">
    <meta name="viewport" content="width=device-width">

    <link rel="icon" type="image/ico" href="./favicon.ico"/>

    <link rel="stylesheet" href="./css/screen.css" />
  </head>
  <body>
    <header>
      <h1>MooVeeStar</h1>
      <p>A client-side MV* Framework built ontop of MooTools</p>
      <p>by Regis Gaughan, III</p>
      <aside>
        <a href="https://github.com/rgthree/mooveestar/" class="ribbon">Fork me on GitHub</a>
      </aside>
    </header>
    <article>

      <section class="quicklinks">
        <nav>
          <ul>
            <li><a href="http://rgthree.github.io/mooveestar/docs/mooveestar.html">Annotated Source/Docs</a></li>
            <li><a href="https://github.com/rgthree/mooveestar/">GitHub Repo</a></li>
            <li><a href="https://raw.github.com/rgthree/mooveestar/master/mooveestar-min.js">Download (Minified)</a></li>
            <li><a href="https://raw.github.com/rgthree/mooveestar/master/src/mooveestar.js">Download (Full)</a></li>
          </ul>
        </nav>
      </section>

      <p>MooVeeStar is a client-side MV* Framework built ontop of MooTools. It has been built to feel familiar while harnessing the power and practices of the MooTools library.</p>

      <h2>Introduction</h2>
      <p>The advancement of JavaScript the past decade has been nothing short of breathtaking. No longer is it a simple tool to popup an image slideshow or validate a contact form. It is a powerful tool that can be used to drive massive single-page websites. And if you've ever created a large-scale application you know all to well how you can quickly loose control of your client-side codebase in a jumbled mess of JavaScript.</p>
      <p>There are plenty of great JavaScript libraries out there, and no shortage of frameworks to help you structure your code better. Unfortunately, most were built for specific libraries that don't lend themselves well to structured code in the first place, or were built to be <strike>completey</strike> <em>fairly</em> library agnostic. These simply add unnecessary bloat recreating what MooTools already has while simultaneously leaving out powerful features of it. So you've been writing structured code with MooTools already, now MooVeeStar is here to further optimize your development and put your app in the spotlight.</p>

      <h2>Documentation</h2>
      <dl id="classes">
        <dt>MooVeeStar</dt>
        <dd>
          <p>MooVeeStar is the object/namespace that holds the MooVeeStar modules. However, the MooVeeStar object itself is an instantiated MooTools Events object, and can therefore be used as a global mediator between components:</p>
          <code class="block javascript">MooVeeStar.addEvent('someEvent', function(eventObject){
  alert(eventObject.say);
});
MooVeeStar.fireEvent('someEvent', { say:'hi'});</code>
        </dd>

        <dt>MooVeeStar.Model</dt>
        <dd>
          The MooVeeStar.Model is a MooTools class that implements the Events class already.
          <dl>
            <dt data-type="property">idProperty
              <code>model.idProperty</code>
            </dt>
            <dd>
              A configurable key that will be used to uniquely identify the model. It will default to id.
            </dd>

            <dt data-type="property">properties
              <code>model.properties</code>
            </dt>
            <dd>
              <p>A configurable object with a properties hash where you can: Set an initial value; Override the default <code>get</code> and/or <code>set</code> methods; Define <code>validate</code> and/or <code>sanitize</code> methods for each property.</p>
              <code class="block javascript -evalable">var Employee = new Class({
  Extends: MooVeeStar.Model,
  idProperty: 'ssn',
  properties: {
    employed: {
      initial: true
    },
    fullname: {
      set: function(value){
        var names = (value || '').split(' ');
        this.set('firstname', names[0] || null);
        this.set('lastname', names[1] || null);
      },
      get: function(){
        return this.get('firstname')+' '+this.get('lastname');
      }
    },
    ssn: {
      validate: function(value){
        return /^\d{3}-\d{2}-\d{4}$/.test(value) || 'The SSN was not formatted correctly';
      }
    }
  }
});

var employee = new Employee({'ssn':'123-45-6789', 'firstname':'John','lastname':'Smith'});
employee.addEvent('change:ssn', function(event){
  alert(employee.get('fullname') + "'s SSN has changed.");
});
employee.addEvent('error:ssn', function(event){
  alert(event.error);
});
// If the ssn doesn't validate, then error:ssn above will fire
// If the value has changed, then change:ssn above will fire
var ssn = prompt("Enter " + employee.get('fullname') + "'s SSN (XXX-XX-XXXX)", employee.get('ssn'));
if(ssn != null) // Not Cancel
  employee.set('ssn', ssn);
</code>
            </dd>

            <dt data-type="method">initialize/constructor
              <code>new MooVeeStar.Model([object])</code>
            </dt>
            <dd>
            </dd>

            <dt data-type="method">set
              <code>model.set((key, value)|(object), [silent])</code>
            </dt>
            <dd>
              Overloaded set method to set a property or properties on the model. Can be called with a single key/value, or an object with many keys/values. Options can have a silent key that, when true, supresses events.
<code class="block javascript">model.set('name', 'Edward', { silent:true });
// or...
model.set({ name:'Edward' }, { silent:true });
</code>
            </dd>
            
            <dt data-type="method">get
              <code>model.get(keyOrArray, [raw])</code>
            </dt>
            <dd>
              Overloaded get method to get a single value or a map if an array is passed. Passing <code>raw</code> as true will get the raw value directly as it’s stored, without checking if there’s a custom getter within the Model’s properties
            </dd>

            <dt data-type="method">getId
              <code>model.getId()</code>
            </dt>
            <dd>
              Returns an id for the model. If the idProperty exists, it will return it, otherwise it will return a unique string. If there is no cid set yet, it will permenently assign it at this time. MooVeeStar.Collection uses this to identify models within itself.
            </dd>

            <dt data-type="method">unset
              <code>model.unset(keys, [silent])</code>
            </dt>
            <dd>
              Accepts a list of keys and passes them to <code>Model#set</code> with a null value.
            </dd>
            
            <dt data-type="method">destroy
              <code>model.destroy()</code>
            </dt>
            <dd>
              Destroys a model by setting it’s property to an empty map and firing a destroy event
            </dd>
             
            <dt data-type="method">toJSON
              <code>model.toJSON()</code>
            </dt>
            <dd>
              Returns a recursively cloned value map of the model’s raw properties.
            </dd>

            <dt data-type="property">
              cid
              <code>model.cid</code>
            </dt>
            <dd>
              An internal unique identifier. Lazily set in getId(), it will be assigned a unique string if the model has no idProperty value
            </dd>

            <dt data-type="property">
              changed
              <code>model.changed</code>
            </dt>
            <dd>
              An array of all the changed properties of the last set call
            </dd>

            <dt data-type="property">
              errors
              <code>model.errors</code>
            </dt>
            <dd>
              An array of all the properties that had an error of the last set call
            </dd>


          </dl>
        </dd>

        <dt>MooVeeStar.Collection</dt>
        <dd>
          <dl>
            <dt data-type="property">
              errors
              <code>collection.modelClass</code>
            </dt>
            <dd>
              The class of models will auto-instantiate to when added if not an instance of  <code>MooVeeStar.Model</code> already
            </dd>

            <dt data-type="method">
              constructor/initialize
              <code>new MooVeeStar.Collection([models], [options])</code>
            </dt>
            <dd></dd>

            <dt data-type="method">
              add
              <code>collection.add(items, [options])</code>
            </dt>
            <dd>Adds an item to the collection. Will not allow duplicates unless the collection's <code>allowDuplicates</code> is <code>true</code>. Will instantiate the collection's <code>modelClass</code> if the item added is not a <code>MooVeeStar.Model</code>. It is possible to add mixed Model instances. Fires <code>Collection#change</code> and <code>Collection#add</code> and <code>Collection#error</code> events.</dd>
            
            <dt data-type="method">
              remove
              <code>collection.remove(indexOrModels, [options])</code>
            </dt>
            <dd>Removes a model by index or all instance of a model or array of models from the collection. If <code>indexOrModels</code> is a number, then remove at that index; if it is a string id, then get the model and remove all instances of it; if it is a model or array of models, then remove all instances of each. Fires <code>Collection#change</code> and <code>Collection#remove</code> events.</dd>
            
            <dt data-type="method">
              empty
              <code>collection.empty([options])</code>
            </dt>
            <dd>Empties the Collection by callng <code>remove</code> on all items</dd>

            <dt data-type="method">
              move
              <code>collection.move(indexOrModel, to, [options])</code>
            </dt>
            <dd>Moves a model from one index to another. If <code>indexOrModel</code> is a number, then move the model at that index. If it is a model then only whose first instance of the model in the collection will be moved.</dd>

            <dt data-type="method">
              getId
              <code>collection.getId()</code>
            </dt>
            <dd></dd>
            
            <dt data-type="method">
              getLength
              <code>collection.getLength()</code>
            </dt>
            <dd>Returns the number of items in the collection</dd>
            
            <dt data-type="method">
              at
              <code>collection.at(index)</code>
            </dt>
            <dd>Returns the model at a specific index, if it exists.</dd>
            
            <dt data-type="method">
              get
              <code>collection.get([key])</code>
            </dt>
            <dd>Returns the first model found from the key. If <code>key</code> is <code>null</code>, return all items; or call <code>Collection:findFirst</code> with <code>key</code>; or if <code>key</code> is numeric call C</code>ollection:at</code></dd>
            
            <dt data-type="method">
              getAll
              <code>collection.getAll()</code>
            </dt>
            <dd>Returns the list of models</dd>
            
            <dt data-type="method">
              find
              <code>collection.find(values, [keyToFind])</code>
            </dt>
            <dd>Accept a value or list of values and returns any models who’s idProperty is within the values list. Pass <code>keyToFind</code> to compare that key’s value instread of <code>idProperty</code></dd>
            
            <dt data-type="method">
              findFirst
              <code>collection.findFirst(value, [keyToFind])</code>
            </dt>
            <dd>Returns the first model whos <code>idProperty</code> (or <code>keyToFind</code> value) matches the passed value</dd>

            <dt data-type="method">
              toJSON
              <code>collection.toJSON()</code>
            </dt>
            <dd>Returns a _new array_ of all of the <code>Models.toJSON</code> values</dd>

            <dt data-type="method">
              destroy
              <code>collection.destroy([options])</code>
            </dt>
            <dd>Silently empties the list and fires a destroy message</dd>

            <dt data-type="method">
              applyToModels
              <code>collection.applyToModels(operation, opArgs, modelsOrFindValues, findKeyToFind)</code>
            </dt>
            <dd>Calls a method on all models, or all models found
              <code class="block javascript">// Set all models to complete
collection.applyToModels('set', ['complete', true]);

// Set all models whos 'complete' key is === false
collection.applyToModels('set', [{ complete:true }], false, 'complete');

// Unset 'complete' and 'due' on models whos 'complete' key is === false
collection.applyToModels('unset', [['complete','due']], collection.find(false, 'complete'));</code></dd>

          </dl>

          <h3>Array Methods</h3>
          <p>
            <code>forEach</code> <code>each</code> <code>every</code> <code>invoke</code> <code>filter</code> <code>map</code> <code>some</code> <code>indexOf</code> <code>contains</code> <code>getRandom</code> <code>getLast</code>
          </p>
        </dd>


        <dt>MooVeeStar.View</dt>
        <dd>
          <p>MooVeeStar views help you take control of how your interface interacts with user input and data changes. It was built to take full power of the MooVeeStar.Templating system, but can be used with any templating library.</p>
          <h3>Extending</h3>
          <p>You will be creating your own, extended views by overriding some of the properties and methods. If you're using the MooVeeStar templating system then all you really need is to define a template name. Here's a simple view that renders a template, with a couple events:</p>
          <code class="block javascript">var EmployeeIdView = new Class({
  Extends: MooVeeStar.View,
  events: {
    'model:change':'render',
    'click:relay(button.delete)':'destroy'
  },
  template:'employee-id-card'
});

$(document.body).grab(new EmployeeIdView(existingEmployeeModel));</code>

          <dl>
            <dt data-type="method">
              constructor/initialize
              <code>new MooVeeStar.View([model], [options])</code>
            </dt>
            <dd>
              <p>The MooVeeStar.View constructor sets a few things for us upfront. As you will likely be overriding the constructor when defining your own view, the placement of your parent call could be important.</p>
              <ul>
                <li>Sets and merges the passed <code>options</code> object to the default options</li>
                <li>Sets the <code>model</code> property to the passed model, if it is not previously defined</li>
                <li>Inflates the template from the Views template and sets it to the <code>element</code> property as well as <code>elements.container</code></li>
                <li>Attaches the events, unless <code>options.autoattach</code> is false</li>
                <li>Calls render, unless <code>options.autorender</code> is false</li>
              </ul>
            </dd>



            <dt data-type="property">
              options
              <code>view.options</code>
            </dt>
            <dd>
              MooVeeStar.View implements the MooTools Options methods by default, and comes with a few options to run itself upfront, usually overriden when defining your own, extended view.
              <code class="block javascript">{
  autorender: true,  // Automatically call the render function on initialization 
  autoattach: true   // Automatically attach events on initialization
  inflater: MooVeeStar.Templates.inflate,  // The template inflate method. Called as: "inflater(this.template, null)"
                                           // by default when intializing the element
  binder: MooVeeStar.Templates.bind        // The template binder method. Called as: "binder(this.element, model.toJSON())"
                                           // by default in "this.render"
}</code>
              <strong>autorender</strong>
            </dd>

            <dt data-type="property">
              events
              <code>model.events</code>
            </dt>
            <dd>
              <p>Events are what automate your view's interface with user input, data changes, interface changes... really anything. If it can fire an event your view can listen to it. You can bind events to any property that is defined in your constructor before calling <code>this.parent()</code>. The event object is a set of string event-keys, with string function names.</p>
              <h4>How's it work?</h4>
              <p>The events are somewhat magical. There is a lot you can throw at it, and it will only fail when it can't find what you're trying to attach to, or the string method name doesn't exist on your view. The event string syntax can be generalized as <code>'attachmentObject:eventToListen'</code>. The <code>attachmentObject</code> should be: an existing property of the view, <code>this</code>, <code>window</code>, <code>document</code>, <code>MooVeeStar</code>, an existing element html-id, or an object on <code>window</code>. If you do not supply an <code>attachmentObject</code>, then it will attempt to use the <code>this.element</code> <em>only if the <code>eventToListen</code> is an <code>Element.NativeEvents</code></em>, otherwise it will listen to the view's own events. Here's some examples:</p>
              <code class="block javascript">var MyView = new Class({
  Extends: MooVeeStar.View,
  events: {
    'model:change': 'render',          // Listen for 'change' events on 'this.model'
    'this.model:change': 'render',     // (Same as above)
    'model:change:name': 'render',     // Listen for the specific 'change:name' events on 'this.model'

    'click': 'onClick',                // Listen for 'click' events on 'this.element'
    'element:click': 'onClick',        // (Same as above)
    'this.element:click': 'onClick',   // (Same as above)
    'this:click': 'onFiredClick',      // Not a mouse-click! Force listening to an internal view event
                                       // named "click" fired through 'this.fireEvent("click")'

    'click:relay(button)': 'onButtonClick',   // Listen for 'click' events on button children of 'this.element'
    'elements.button:click': 'onButtonClick', // Assuming 'this.elements.button' was set before attaching events
                                              // this will listen for clicks on this element
    'someProperty:some-event': 'someFn',      // Assuming 'this.someProperty' exists and has an 'addEvent' method
    'this.someProperty:some-event': 'someFn', // (Same as above)

    'window:scroll': 'onWindowScroll',        // Window Scroll event
    'document:click': 'onWindowScroll',       // Click events on the 'document'

    'MooVeeStar:some-event': 'someFn',        // Listen for 'some-event' fired through the MooVeeStar mediator

    'someGlobalObject:some-event': 'someFn',  // Assuming 'window.someGlobalObject' exists and has an 'addEvent' method

    'someHtmlId:keydown':'onSomeKeydown'      // Assuming an element with 'id="someHtmlId"', listen for it's keydowns
  },
  initialize: function(model, options){
    // Need to define these per the above before calling this.parent
    this.elements.button = $('aButtonsId');
    this.someProperty = new ClassWithEvents();
    this.parent(model, options); // Auto attaching events
  },
  /* the defined event callback methods from above */
});</code>
              <p class="tip -caution">A view error will be thrown if: You attempt to attach events to something that does not exist or does not have a <code>addEvent</code> method; or the listeners callback method name does not exist on your view.</p>
            </dd>

            <dt data-type="property">
              template
              <code>view.template</code>
            </dt>
            <dd>
              The string key of the template to use. Can also be an element. The template will get inflated and set as <code>this.element</code>
            </dd>

            <dt data-type="property">
              model
              <code>view.model</code>
            </dt>
            <dd>
              The view model. A view can have as many models as you would like and all can be used in any facility. A <code>view.model</code> will be setup by default in the view constructor.
            </dd>
            
            <dt data-type="property">
              element
              <code>view.element</code>
            </dt>
            <dd>
              The element inflated from <code>view.template</code>
            </dd>
            
            <dt data-type="property">
              elements
              <code>view.elements</code>
            </dt>
            <dd>
              A map for elements to be cached to for use in either the events map, or in other view methods. The <code>view.element</code> is added automatically as  <code>view.elements.container</code> as well.
            </dd>

            <dt data-type="method">
              render
              <code>view.render([data])</code>
            </dt>
            <dd>
              Likely overridden and called through parent(), this determines the data to bind to the element. Pass a MooVeeStar.Event instance which contains a changed key, it will only rebind those changed values. Otherwise, it will use the passed argument or, more likely, call model.toJSON
            </dd>

            <dt data-type="method">
              toElement
              <code>view.toElement()</code>
            </dt>
            <dd>Returns the <code>this.element</code>. Automatically called by MooTools when the view is used as an element, like: <code>$(myView)</code> or <code>document.body.grab(myView)</code></dd>

            <dt data-type="method">
              destroy
              <code>view.destroy([element])</code>
            </dt>
            <dd>
              <p>Destroy the element, detaching all events and any child elements with view controller's events.</p>
              <p class="tip -caution">You should ensure to destroy your views by calling <code>view.destroy()</code> and avoid removing the element directly, either through <code>this.element.destroy()</code>, or <code>someParentElement.empty()</code>, etc. Doing so will not detach all event listeners.</p>
            </dd>

            <dt data-type="method">
              empty
              <code>view.empty([element])</code>
            </dt>
            <dd>
              Empties the passed element, or the view’s element. Calls view.destroy() for all attached views within the element’s DOM. Fires the View#empty event
            </dd>

            <dt data-type="method">
              dispose
              <code>view.dispose([element])</code>
            </dt>
            <dd>
              Disposes of an element, or the view’s element. This does not affect and attached sub views (like destroy and empty). Fires the View#dispose event
            </dd>

            <dt data-type="method">
              attach
              <code>view.attach([element], [excludeSelf])</code>
            </dt>
            <dd>Attaches all the events in the <code>this.events</code> map, as well as attaching all child elements with a view controller</dd>

            <dt data-type="method">
              detach
              <code>view.detach([element], [excludeSelf])</code>
            </dt>
            <dd>Detaches all the events in the <code>this.events</code> map, as well as attaching all child elements with a view controller</dd>

          </dl>

        </dd>

      </dl>
    </article>

    <script>
    /* Modernizr 2.7.1 (Custom Build) | MIT & BSD
     * Build: http://modernizr.com/download/#-csstransforms-cssclasses-testprop-testallprops-domprefixes
     */
    ;window.Modernizr=function(a,b,c){function x(a){j.cssText=a}function y(a,b){return x(prefixes.join(a+";")+(b||""))}function z(a,b){return typeof a===b}function A(a,b){return!!~(""+a).indexOf(b)}function B(a,b){for(var d in a){var e=a[d];if(!A(e,"-")&&j[e]!==c)return b=="pfx"?e:!0}return!1}function C(a,b,d){for(var e in a){var f=b[a[e]];if(f!==c)return d===!1?a[e]:z(f,"function")?f.bind(d||b):f}return!1}function D(a,b,c){var d=a.charAt(0).toUpperCase()+a.slice(1),e=(a+" "+n.join(d+" ")+d).split(" ");return z(b,"string")||z(b,"undefined")?B(e,b):(e=(a+" "+o.join(d+" ")+d).split(" "),C(e,b,c))}var d="2.7.1",e={},f=!0,g=b.documentElement,h="modernizr",i=b.createElement(h),j=i.style,k,l={}.toString,m="Webkit Moz O ms",n=m.split(" "),o=m.toLowerCase().split(" "),p={},q={},r={},s=[],t=s.slice,u,v={}.hasOwnProperty,w;!z(v,"undefined")&&!z(v.call,"undefined")?w=function(a,b){return v.call(a,b)}:w=function(a,b){return b in a&&z(a.constructor.prototype[b],"undefined")},Function.prototype.bind||(Function.prototype.bind=function(b){var c=this;if(typeof c!="function")throw new TypeError;var d=t.call(arguments,1),e=function(){if(this instanceof e){var a=function(){};a.prototype=c.prototype;var f=new a,g=c.apply(f,d.concat(t.call(arguments)));return Object(g)===g?g:f}return c.apply(b,d.concat(t.call(arguments)))};return e}),p.csstransforms=function(){return!!D("transform")};for(var E in p)w(p,E)&&(u=E.toLowerCase(),e[u]=p[E](),s.push((e[u]?"":"no-")+u));return e.addTest=function(a,b){if(typeof a=="object")for(var d in a)w(a,d)&&e.addTest(d,a[d]);else{a=a.toLowerCase();if(e[a]!==c)return e;b=typeof b=="function"?b():b,typeof f!="undefined"&&f&&(g.className+=" "+(b?"":"no-")+a),e[a]=b}return e},x(""),i=k=null,e._version=d,e._domPrefixes=o,e._cssomPrefixes=n,e.testProp=function(a){return B([a])},e.testAllProps=D,g.className=g.className.replace(/(^|\s)no-js(\s|$)/,"$1$2")+(f?" js "+s.join(" "):""),e}(this,this.document);
    </script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/mootools/1.4.5/mootools-core-full-compat-yc.js"></script>
    <script src="./js/mooveestar.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/7.3/highlight.min.js"></script>
    <script>
      // Highlighting
      $$('code.block').each(function(el){ el.set('html', hljs.highlight('javascript', el.get('text')).value); });
      // Runable

      // Set up the "play" buttons for each runnable code example.
      $$('code.block.-evalable').each(function(el){
        var btn, code;
        code = el.get('text');
        btn = new Element('button.evaler[text="Run"]').addEvent('click', function(){
          eval(code);
        }).inject(el, 'before');
      });


    </script>
  </body>
</html>